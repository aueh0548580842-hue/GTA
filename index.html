<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>×¨×‘×™ ×¢×§×™×‘× Pro - ×’×¨×¡×ª ×”×ª×™×§×•×Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background: #020205; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #ui {
            position: absolute; top: 10px; right: 10px;
            color: #fff; background: rgba(0,0,0,0.85);
            padding: 15px; border-right: 5px solid #ffcc00; border-radius: 8px;
            pointer-events: none; z-index: 100; font-weight: bold; font-size: 16px; text-align: right;
        }
        #controls {
            position: absolute; bottom: 30px; left: 30px;
            display: grid; grid-template-columns: repeat(3, 80px); grid-gap: 10px; z-index: 100;
        }
        .btn {
            width: 80px; height: 80px; background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.3); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 35px; user-select: none;
        }
        .btn:active { transform: scale(0.9); background: rgba(255,255,255,0.2); }
        #alert {
            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
            color: #ff0000; font-size: 30px; font-weight: bold; display: none; z-index: 1000;
            text-shadow: 2px 2px #000; text-align: center; pointer-events: none;
        }
        @media (min-width: 1024px) { #controls { display: none; } }
    </style>
</head>
<body>

    <div id="alert">× ×™×™×“×ª ××©×˜×¨×” ×‘××¨×“×£! ğŸš”</div>
    <div id="ui">
        <strong>×¨×—×•×‘ ×¨×‘×™ ×¢×§×™×‘× - ×ª×™×§×•×Ÿ ×ª×¦×•×’×”</strong><br>
        ×¢×‘×™×¨×•×ª: <span id="violation-count">0</span>/3<br>
        <small>×—×¦×™× ×œ× ×”×™×’×” | ×¨×•×•×— ×œ×¦×•×¤×¨</small>
    </div>

    <div id="controls">
        <div id="up" class="btn" style="grid-column: 2;">â†‘</div>
        <div id="left" class="btn" style="grid-column: 1; grid-row: 2;">â†</div>
        <div id="down" class="btn" style="grid-column: 2; grid-row: 2;">â†“</div>
        <div id="right" class="btn" style="grid-column: 3; grid-row: 2;">â†’</div>
        <div id="horn" class="btn" style="grid-column: 3; grid-row: 1;">ğŸ“¢</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>

    <script>
        // --- Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205);
        scene.fog = new THREE.Fog(0x000000, 10, 450);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambLight = new THREE.AmbientLight(0x404050, 0.8);
        scene.add(ambLight);

        // --- Road (No Textures for stability) ---
        const road = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 4000), 
            new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.2 })
        );
        road.rotation.x = -Math.PI / 2; scene.add(road);

        // --- Rain ---
        const rainGeo = new THREE.BufferGeometry();
        const rainPos = new Float32Array(3000 * 3);
        for(let i=0; i<9000; i+=3) { 
            rainPos[i]=(Math.random()-0.5)*200; 
            rainPos[i+1]=Math.random()*100; 
            rainPos[i+2]=(Math.random()-0.5)*800; 
        }
        rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
        const rain = new THREE.Points(rainGeo, new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.1 }));
        scene.add(rain);

        // --- Simple Buildings ---
        for(let z=-1500; z<1500; z+=100) {
            const h = 30 + Math.random()*40;
            const bL = new THREE.Mesh(new THREE.BoxGeometry(20, h, 40), new THREE.MeshStandardMaterial({color: 0x0a0a0f}));
            bL.position.set(-45, h/2, z); scene.add(bL);
            const bR = bL.clone(); bR.position.x = 45; scene.add(bR);
        }

        // --- Traffic Lights ---
        const INTERSECTIONS = [-800, -400, 0, 400, 800];
        const lights = [];
        INTERSECTIONS.forEach(z => {
            const g = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 12), new THREE.MeshStandardMaterial({color: 0x222}));
            pole.position.y = 6; g.add(pole);
            const r = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color: 0x300}));
            r.position.set(0, 11, 0.8); g.add(r);
            const gr = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color: 0x030}));
            gr.position.set(0, 9, 0.8); g.add(gr);
            g.position.set(28, 0, z); scene.add(g);
            lights.push({r, gr, z});
        });

        // --- Player Car ---
        const player = new THREE.Group();
        const car = new THREE.Mesh(new THREE.BoxGeometry(2.5, 1.5, 5), new THREE.MeshStandardMaterial({color: 0x0055ff}));
        car.position.y = 0.75; player.add(car);
        const headL = new THREE.SpotLight(0xffffff, 10, 100); headL.position.set(0, 1, 2.5); player.add(headL);
        player.userData = { speed: 0, angle: 0, violations: 0 };
        scene.add(player);

        // --- Input ---
        const keys = {};
        window.onkeydown = e => keys[e.code] = true;
        window.onkeyup = e => keys[e.code] = false;

        function animate() {
            requestAnimationFrame(animate);

            // Logic: Traffic State
            const state = (Date.now() % 10000 < 5000) ? "GREEN" : "RED";
            lights.forEach(l => {
                l.r.material.color.set(state === "RED" ? 0xff0000 : 0x330000);
                l.gr.material.color.set(state === "GREEN" ? 0x00ff00 : 0x003300);
            });

            // Player Physics
            if(keys['ArrowUp'] || keys['KeyW']) player.userData.speed += 0.02;
            if(keys['ArrowDown'] || keys['KeyS']) player.userData.speed -= 0.02;
            player.userData.speed *= 0.96;
            if(Math.abs(player.userData.speed) > 0.1) {
                if(keys['ArrowLeft'] || keys['KeyA']) player.userData.angle += 0.03;
                if(keys['ArrowRight'] || keys['KeyD']) player.userData.angle -= 0.03;
            }
            player.position.x += Math.sin(player.userData.angle) * player.userData.speed;
            player.position.z += Math.cos(player.userData.angle) * player.userData.speed;
            player.rotation.y = player.userData.angle;

            // Violation check
            if(state === "RED") {
                lights.forEach(l => {
                    if(Math.abs(player.position.z - l.z) < 10 && !player.userData.violated) {
                        player.userData.violations++;
                        player.userData.violated = true;
                        document.getElementById('violation-count').innerText = Math.min(player.userData.violations, 3);
                        setTimeout(() => player.userData.violated = false, 3000);
                    }
                });
            }

            // Rain movement
            const p = rainGeo.attributes.position.array;
            for(let i=1; i<p.length; i+=3) { p[i]-=1.5; if(p[i]<0) p[i]=100; }
            rainGeo.attributes.position.needsUpdate = true;
            rain.position.z = player.position.z;

            // Camera follow
            camera.position.set(player.position.x - Math.sin(player.userData.angle)*18, 9, player.position.z - Math.cos(player.userData.angle)*18);
            camera.lookAt(player.position.x, 2, player.position.z);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
