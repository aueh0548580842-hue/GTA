<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>רבי עקיבא Pro - צמתים מלאים</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #ui {
            position: absolute; top: 10px; right: 10px;
            color: #fff; background: rgba(0,0,0,0.85);
            padding: 15px; border-right: 5px solid #ffcc00; border-radius: 8px;
            pointer-events: none; z-index: 100; font-weight: bold; font-size: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            text-align: right;
        }
        #controls {
            position: absolute; bottom: 30px; left: 30px;
            display: grid; grid-template-columns: repeat(3, 80px); grid-gap: 10px;
            z-index: 100;
        }
        .btn {
            width: 80px; height: 80px; background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.5); border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 35px; user-select: none; backdrop-filter: blur(5px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .btn:active { transform: scale(0.95); background: rgba(255,255,255,0.3); }
        @media (min-width: 1024px) { #controls { display: none; } }
    </style>
</head>
<body>

    <div id="ui">
        <strong>רחוב רבי עקיבא - המלא</strong><br>
        מסלול: גן ורשה -> חזון איש -> אהרונוביץ'<br>
        הפרדה ע"י סימון כביש בלבד.<br>
        שים לב לרמזורים ולשילוט!
    </div>

    <div id="controls">
        <div id="up" class="btn" style="grid-column: 2;">↑</div>
        <div id="left" class="btn" style="grid-column: 1; grid-row: 2;">←</div>
        <div id="down" class="btn" style="grid-column: 2; grid-row: 2;">↓</div>
        <div id="right" class="btn" style="grid-column: 3; grid-row: 2;">→</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- הגדרות בסיס ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 30, 450);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1500);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // --- טקסטורות ---
        const texLoader = new THREE.TextureLoader();
        const asphaltTex = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-big.jpg');
        asphaltTex.wrapS = asphaltTex.wrapT = THREE.RepeatWrapping; asphaltTex.repeat.set(20, 100);
        asphaltTex.encoding = THREE.sRGBEncoding;

        const pavingTex = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg');
        pavingTex.wrapS = pavingTex.wrapT = THREE.RepeatWrapping; pavingTex.repeat.set(4, 50);

        const stoneTex = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_diffuse.jpg');
        stoneTex.wrapS = stoneTex.wrapT = THREE.RepeatWrapping;

        // --- תאורה ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambLight);
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(150, 300, 100);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 4096; sun.shadow.mapSize.height = 4096;
        sun.shadow.camera.left = -500; sun.shadow.camera.right = 500;
        sun.shadow.camera.top = 800; sun.shadow.camera.bottom = -800;
        scene.add(sun);

        // --- הגדרת הרחוב והצמתים ---
        const ROAD_WIDTH = 50; 
        const STREET_LENGTH = 2000;

        // רשימת הצמתים לפי מיקום Z
        const INTERSECTIONS = [
            { z: -600, name: "גן ורשה / ירושלים" },
            { z: -300, name: "רחוב הרב קוק" },
            { z: 0, name: "רחוב חזון איש" },
            { z: 300, name: "רחוב הרב שך" },
            { z: 600, name: "רחוב אהרונוביץ'" }
        ];

        // 1. כביש ראשי
        const road = new THREE.Mesh(
            new THREE.PlaneGeometry(ROAD_WIDTH, STREET_LENGTH),
            new THREE.MeshStandardMaterial({ map: asphaltTex, color: 0x555555, roughness: 0.8 })
        );
        road.rotation.x = -Math.PI / 2;
        road.receiveShadow = true;
        scene.add(road);

        // 2. מדרכות לאורך כל הדרך
        const swGeo = new THREE.PlaneGeometry(20, STREET_LENGTH);
        const swMat = new THREE.MeshStandardMaterial({ map: pavingTex, color: 0xbbbbbb });
        const swL = new THREE.Mesh(swGeo, swMat); swL.rotation.x = -Math.PI/2; swL.position.set(-ROAD_WIDTH/2 - 10, 0.1, 0); swL.receiveShadow = true; scene.add(swL);
        const swR = new THREE.Mesh(swGeo, swMat); swR.rotation.x = -Math.PI/2; swR.position.set(ROAD_WIDTH/2 + 10, 0.1, 0); swR.receiveShadow = true; scene.add(swR);

        // 3. סימוני כביש (ללא גדר!)
        const paintMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        // קו הפרדה כפול (לבן)
        const lineGeo = new THREE.PlaneGeometry(0.5, STREET_LENGTH);
        const l1 = new THREE.Mesh(lineGeo, paintMat); l1.rotation.x = -Math.PI/2; l1.position.set(-0.5, 0.05, 0); scene.add(l1);
        const l2 = new THREE.Mesh(lineGeo, paintMat); l2.rotation.x = -Math.PI/2; l2.position.set(0.5, 0.05, 0); scene.add(l2);

        // קווקווים בין נתיבים
        const dashGeo = new THREE.PlaneGeometry(0.4, 4);
        for(let z=-STREET_LENGTH/2; z<STREET_LENGTH/2; z+=10) {
            const d1 = new THREE.Mesh(dashGeo, paintMat); d1.rotation.x = -Math.PI/2; d1.position.set(12, 0.05, z); scene.add(d1);
            const d2 = new THREE.Mesh(dashGeo, paintMat); d2.rotation.x = -Math.PI/2; d2.position.set(-12, 0.05, z); scene.add(d2);
        }

        // --- אובייקטים ופונקציות ---
        const colliders = [];

        // יצירת שלט רחוב
        function createSign(text, x, z) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#005500'; 
            ctx.fillRect(0,0,512,128);
            ctx.strokeStyle = 'white'; ctx.lineWidth = 10; ctx.strokeRect(5,5,502,118);
            ctx.fillStyle = 'white'; ctx.font = 'bold 50px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 256, 64);
            
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(12, 4, 0.2), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas) }));
            mesh.position.set(x, 8, z);
            if(x > 0) mesh.rotation.y = -Math.PI/2; else mesh.rotation.y = Math.PI/2;
            scene.add(mesh);

            // עמוד לשלט
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 8, 8), new THREE.MeshStandardMaterial({ color: 0x444444 }));
            pole.position.set(x, 4, z);
            scene.add(pole);
        }

        // יצירת רמזור
        function createTrafficLight(x, z) {
            const g = new THREE.Group();
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 8, 8), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            pole.position.y = 4; g.add(pole);
            const box = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            box.position.y = 7; g.add(box);
            const r = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshBasicMaterial({ color: 0xff0000 })); r.position.set(0,8,0.6); g.add(r);
            const gr = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshBasicMaterial({ color: 0x00ff00 })); gr.position.set(0,6,0.6); g.add(gr);
            g.position.set(x, 0, z);
            // אם בצד ימין מסובב שמאלה ולהפך
            if(x > 0) g.rotation.y = -Math.PI/2; else g.rotation.y = Math.PI/2;
            scene.add(g);
        }

        // יצירת בניין ריאליסטי
        function createBuilding(x, z) {
            const w = 18; const h = 20 + Math.random()*20; const d = 20;
            const g = new THREE.Group(); g.position.set(x, 0, z);
            
            const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ map: stoneTex, color: 0xe0dacc }));
            b.position.y = h/2; b.castShadow = true; b.receiveShadow = true; g.add(b);

            // מרפסות
            for(let level=5; level<h-4; level+=4) {
                const bal = new THREE.Mesh(new THREE.BoxGeometry(w-4, 1.5, 3), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                bal.position.set(0, level, (x>0 ? -d/2-1.5 : d/2+1.5)); g.add(bal);
            }
            // סוכך חנות
            const awn = new THREE.Mesh(new THREE.BoxGeometry(w, 0.5, 4), new THREE.MeshStandardMaterial({ color: Math.random()>0.5?0x003366:0x660000 }));
            awn.position.set(0, 4, (x>0 ? -d/2-2 : d/2+2)); g.add(awn);

            scene.add(g);
            colliders.push(new THREE.Box3().setFromObject(b));
        }

        // יצירת מנורת רחוב
        function createLamp(x, z) {
            const p = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 9, 8), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            p.position.set(x, 4.5, z); scene.add(p);
            const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshBasicMaterial({ color: 0xffffaa }));
            bulb.position.set(x + (x>0?-1.5:1.5), 9, z); scene.add(bulb);
        }

        // --- לולאת הבנייה הראשית (עם דילוג בצמתים) ---
        for(let z = -900; z < 900; z += 26) {
            // בדיקה האם המיקום הנוכחי קרוב לאחד הצמתים
            let isIntersection = false;
            let currentInter = null;
            
            INTERSECTIONS.forEach(inter => {
                if (Math.abs(z - inter.z) < 40) { // רדיוס של 40 מטר לצומת
                    isIntersection = true;
                    currentInter = inter;
                }
            });

            if (isIntersection) {
                // אם אנחנו בדיוק במרכז הצומת (בערך), נבנה כביש חוצה ושלטים
                if (Math.abs(z - currentInter.z) < 5) {
                    // כביש חוצה
                    const cross = new THREE.Mesh(new THREE.PlaneGeometry(200, 40), new THREE.MeshStandardMaterial({ map: asphaltTex, color: 0x555555 }));
                    cross.rotation.x = -Math.PI/2; cross.position.set(0, 0.02, z); scene.add(cross);
                    
                    // רמזורים
                    createTrafficLight(30, z + 20);
                    createTrafficLight(-30, z - 20);

                    // שלטים
                    createSign(currentInter.name, 35, z - 10);
                    createSign(currentInter.name, -35, z + 10);
                }
                continue; // מדלגים על בניית בניין
            }

            // בנייה רגילה
            createBuilding(45, z);
            createBuilding(-45, z);

            if (z % 52 === 0) {
                createLamp(30, z);
                createLamp(-30, z);
            }
        }

        // --- יצירת רכב משודרג ---
        function createCarMesh(color, isBus) {
            const g = new THREE.Group();
            const l = isBus ? 12 : 4.8, w = isBus ? 3.5 : 2.2, h = isBus ? 3.5 : 1.4, wy = isBus ? 0.8 : 0.4;
            
            // גוף
            const b = new THREE.Mesh(new THREE.BoxGeometry(w, h-wy, l), new THREE.MeshStandardMaterial({ color: color, roughness:0.2, metalness:0.3 }));
            b.position.y = wy + (h-wy)/2; b.castShadow = true; g.add(b);
            
            // גג לרכב פרטי
            if(!isBus) {
                const c = new THREE.Mesh(new THREE.BoxGeometry(w-0.4, 0.6, l*0.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                c.position.set(0, h+0.2, -0.2); g.add(c);
            }

            // גלגלים
            const wg = new THREE.CylinderGeometry(wy, wy, w+0.2, 12); wg.rotateZ(Math.PI/2);
            const wm = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const w1=new THREE.Mesh(wg,wm); w1.position.set(0,wy,l*0.35); g.add(w1);
            const w2=new THREE.Mesh(wg,wm); w2.position.set(0,wy,-l*0.35); g.add(w2);

            // פנסים
            const lg=new THREE.BoxGeometry(w*0.2,0.2,0.1);
            const hl=new THREE.Mesh(lg,new THREE.MeshBasicMaterial({color:0xffffaa})); hl.position.set(w*0.3,wy+0.5,l/2+0.05); g.add(hl);
            const hll=hl.clone(); hll.position.set(-w*0.3,wy+0.5,l/2+0.05); g.add(hll);
            
            return g;
        }

        // --- שחקן ---
        const player = createCarMesh(0x0044ff, false);
        player.position.set(6, 0, -850); // מתחיל לפני גן ורשה
        player.userData = { speed: 0, angle: 0 };
        scene.add(player);

        // --- תנועה ---
        const traffic = [];
        const lanes = [6, 18, -6, -18];

        function spawnTraffic() {
            for(let i=0; i<45; i++) {
                const lane = lanes[Math.floor(Math.random()*lanes.length)];
                const isBus = Math.random() < 0.25;
                const c = createCarMesh(isBus?0xffcc00:Math.random()*0xffffff, isBus);
                const z = (Math.random()-0.5)*1800;
                c.position.set(lane, 0, z);
                
                const dir = lane > 0 ? 1 : -1;
                if(dir === -1) c.rotation.y = Math.PI;
                c.userData = { lane: lane, speed: (isBus?0.18:0.32)*dir };
                scene.add(c);
                traffic.push(c);
            }
        }
        spawnTraffic();

        // --- לוגיקה ---
        const keys = {};
        window.onkeydown = e => keys[e.code] = true;
        window.onkeyup = e => keys[e.code] = false;

        function animate() {
            requestAnimationFrame(animate);

            if (keys['KeyW'] || keys['ArrowUp']) player.userData.speed += 0.01;
            if (keys['KeyS'] || keys['ArrowDown']) player.userData.speed -= 0.01;
            player.userData.speed *= 0.96;

            if (Math.abs(player.userData.speed) > 0.001) {
                const turn = (keys['KeyA'] || keys['ArrowLeft']) ? 0.03 : ((keys['KeyD'] || keys['ArrowRight']) ? -0.03 : 0);
                player.userData.angle += turn * (player.userData.speed / 0.5);
            }

            const nextX = player.position.x + Math.sin(player.userData.angle) * player.userData.speed;
            const nextZ = player.position.z + Math.cos(player.userData.angle) * player.userData.speed;

            const pBox = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(nextX, 0.5, nextZ), new THREE.Vector3(2, 1, 4));
            let crash = false;
            for(const box of colliders) { if (pBox.intersectsBox(box)) { crash = true; break; } }

            if(!crash) { player.position.x = nextX; player.position.z = nextZ; }
            else { player.userData.speed = -player.userData.speed * 0.5; }
            player.rotation.y = player.userData.angle;

            traffic.forEach(t => {
                t.position.z += t.userData.speed;
                if(t.position.z > 950) t.position.z = -950;
                if(t.position.z < -950) t.position.z = 950;
            });

            camera.position.x = player.position.x;
            camera.position.y = 8;
            camera.position.z = player.position.z - (Math.cos(player.userData.angle)*18);
            camera.position.x -= Math.sin(player.userData.angle)*18;
            camera.lookAt(player.position.x, 2, player.position.z);

            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>
