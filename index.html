<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>עיר דו-סטרית מלאה</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #ui {
            position: absolute; top: 10px; right: 10px;
            color: #ffffff; background: rgba(0,0,0,0.8);
            padding: 10px; border: 1px solid #aaa; border-radius: 8px;
            pointer-events: none; z-index: 100; text-shadow: 1px 1px 2px black;
        }
        #controls {
            position: absolute; bottom: 30px; left: 30px;
            display: grid; grid-template-columns: repeat(3, 70px); grid-gap: 15px;
            z-index: 100;
        }
        .btn {
            width: 70px; height: 70px; background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.6); border-radius: 15px;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 30px; user-select: none; backdrop-filter: blur(5px);
        }
        @media (min-width: 1024px) { #controls { display: none; } }
    </style>
</head>
<body>

    <div id="ui">
        <strong>מערכת כבישים דו-סטרית</strong><br>
        שמור על הימין!<br>
        היזהר לא להתנגש ברכבים בנתיב הנגדי.
    </div>

    <div id="controls">
        <div id="up" class="btn">↑</div>
        <div id="left" class="btn">←</div>
        <div id="down" class="btn">↓</div>
        <div id="right" class="btn">→</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- הגדרות מידות העיר ---
        const BLOCK_SIZE = 70;   // גודל המדרכה/בניינים
        const ROAD_WIDTH = 40;   // רוחב הכביש (רחב מספיק ל-2 נתיבים)
        const LANE_OFFSET = 10;  // מרחק הנתיב ממרכז הכביש
        const GRID_SIZE = 6;     // גודל העיר (6x6 בלוקים)
        const TILE_SIZE = BLOCK_SIZE + ROAD_WIDTH; 

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // שמיים
        scene.fog = new THREE.Fog(0x87CEEB, 20, 250); // ערפל להסתרת קצה העולם

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- טעינת טקסטורות ---
        const texLoader = new THREE.TextureLoader();
        const asphaltTex = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-big.jpg');
        asphaltTex.wrapS = asphaltTex.wrapT = THREE.RepeatWrapping; asphaltTex.repeat.set(20, 20);
        
        const concreteTex = texLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg');
        concreteTex.wrapS = concreteTex.wrapT = THREE.RepeatWrapping; concreteTex.repeat.set(2, 2);

        // --- תאורה ---
        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);
        const sun = new THREE.DirectionalLight(0xffffff, 0.8);
        sun.position.set(100, 150, 50);
        sun.castShadow = true;
        sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
        sun.shadow.camera.left = -200; sun.shadow.camera.right = 200;
        sun.shadow.camera.top = 200; sun.shadow.camera.bottom = -200;
        scene.add(sun);

        // --- רצפה ראשית (אספלט) ---
        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(1000, 1000),
            new THREE.MeshStandardMaterial({ map: asphaltTex, color: 0x333333, roughness: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- רשימת גבולות (מדרכות) להתנגשות ---
        const colliders = [];

        // --- פונקציה לבניית בלוק עירוני ---
        function createBlock(x, z) {
            const block = new THREE.Group();
            block.position.set(x, 0, z);

            // מדרכה (אי תנועה)
            const sidewalk = new THREE.Mesh(
                new THREE.BoxGeometry(BLOCK_SIZE, 0.8, BLOCK_SIZE),
                new THREE.MeshStandardMaterial({ map: concreteTex, color: 0x999999 })
            );
            sidewalk.position.y = 0.4;
            sidewalk.castShadow = true; sidewalk.receiveShadow = true;
            block.add(sidewalk);

            // שמירת התנגשות
            const box = new THREE.Box3().setFromObject(sidewalk);
            box.translate(new THREE.Vector3(x, 0, z)); // התאמה למיקום בעולם
            colliders.push(box);

            // בניינים על המדרכה
            const numBuildings = 3 + Math.floor(Math.random() * 4);
            for(let i=0; i<numBuildings; i++) {
                const w = 15 + Math.random() * 10;
                const h = 20 + Math.random() * 40;
                const building = new THREE.Mesh(
                    new THREE.BoxGeometry(w, h, w),
                    new THREE.MeshStandardMaterial({ color: 0x888899 }) // גוון בטון
                );
                
                // פיזור בניינים בתוך המדרכה
                const offset = BLOCK_SIZE/2 - 12;
                building.position.set(
                    (Math.random()-0.5) * offset * 2,
                    h/2 + 0.4,
                    (Math.random()-0.5) * offset * 2
                );
                building.castShadow = true;
                block.add(building);
                
                // חלונות (קוביות שחורות קטנות) - לאווירה
                const winGeo = new THREE.BoxGeometry(0.5, 0.5, 0.2);
                const winMat = new THREE.MeshBasicMaterial({ color: 0xffffaa }); // אור בחלון
                for(let j=0; j<10; j++) {
                     const win = new THREE.Mesh(winGeo, winMat);
                     win.position.set(
                        building.position.x + (w/2 + 0.1), 
                        (Math.random() * h) + 2, 
                        building.position.z + (Math.random()-0.5)*w
                     );
                     if (win.position.y < h) block.add(win);
                }
            }
            scene.add(block);
        }

        // --- בניית הגריד וסימוני הכביש ---
        function createRoadMarkings() {
            // פס הפרדה (קו מקווקו צהוב)
            const dashGeo = new THREE.PlaneGeometry(2, 6);
            const dashMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });

            // לולאה ליצירת הבלוקים וסימוני הכביש
            for (let x = -GRID_SIZE/2; x < GRID_SIZE/2; x++) {
                for (let z = -GRID_SIZE/2; z < GRID_SIZE/2; z++) {
                    const centerX = x * TILE_SIZE;
                    const centerZ = z * TILE_SIZE;
                    
                    // יצירת הבלוק (מדרכה ובניינים)
                    createBlock(centerX, centerZ);

                    // יצירת סימוני כביש (באמצע הרווחים)
                    // קווים אנכיים (לאורך ציר Z)
                    for (let d = -TILE_SIZE/2; d < TILE_SIZE/2; d+=15) {
                        const dash = new THREE.Mesh(dashGeo, dashMat);
                        dash.rotation.x = -Math.PI/2;
                        // ממקם את הפס באמצע הכביש שבין הבלוקים
                        dash.position.set(centerX + TILE_SIZE/2, 0.02, centerZ + d); 
                        scene.add(dash);
                    }
                    // קווים אופקיים (לאורך ציר X)
                    for (let d = -TILE_SIZE/2; d < TILE_SIZE/2; d+=15) {
                        const dash = new THREE.Mesh(dashGeo, dashMat);
                        dash.rotation.x = -Math.PI/2;
                        dash.rotation.z = Math.PI/2;
                        dash.position.set(centerX + d, 0.02, centerZ + TILE_SIZE/2);
                        scene.add(dash);
                    }
                }
            }
        }
        createRoadMarkings();

        // --- בניית רכב (פונקציה גנרית) ---
        function createCarMesh(color) {
            const grp = new THREE.Group();
            
            // גוף
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 0.8, 4.5),
                new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.3 })
            );
            body.position.y = 0.6;
            body.castShadow = true;
            grp.add(body);

            // גג/חלונות
            const top = new THREE.Mesh(
                new THREE.BoxGeometry(1.8, 0.6, 2.5),
                new THREE.MeshStandardMaterial({ color: 0x333333 }) // חלונות כהים
            );
            top.position.set(0, 1.3, -0.2);
            grp.add(top);

            // פנסים
            const light = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.1), new THREE.MeshBasicMaterial({ color: 0xffffaa }));
            const l1 = light.clone(); l1.position.set(-0.7, 0.7, 2.25);
            const l2 = light.clone(); l2.position.set(0.7, 0.7, 2.25);
            grp.add(l1); grp.add(l2);

            return grp;
        }

        // --- שחקן ---
        const player = createCarMesh(0xd92b2b); // אדום
        // מתחילים בכביש, בנתיב הימני
        player.position.set(BLOCK_SIZE/2 + LANE_OFFSET, 0, 0); 
        scene.add(player);

        // --- רכבי AI (תנועה דו כיוונית) ---
        const traffic = [];
        const trafficColors = [0xffffff, 0x333333, 0x2244aa, 0x228822, 0xaa6600];

        // פונקציה ליצירת רכבים בכבישים האנכיים והאופקיים
        function spawnTraffic() {
            // כבישים אנכיים (ציר Z)
            for (let i = 0; i < 20; i++) {
                const t = createCarMesh(trafficColors[Math.floor(Math.random()*trafficColors.length)]);
                
                // בוחרים "טור" של כביש באופן רנדומלי
                const colIndex = Math.floor((Math.random() - 0.5) * GRID_SIZE); 
                const roadCenterX = colIndex * TILE_SIZE + TILE_SIZE/2;

                // החלטה על כיוון: 
                // כיוון 1 (דרום): נוסעים בנתיב הימני (X חיובי ביחס למרכז הכביש)
                // כיוון -1 (צפון): נוסעים בנתיב השמאלי (X שלילי ביחס למרכז הכביש)
                const dir = Math.random() > 0.5 ? 1 : -1;
                
                // מיקום הנתיב: מרכז הכביש + (כיוון * מרחק הנתיב)
                // אבל בישראל נוהגים בימין, אז אם אני נוסע דרומה (Z עולה), אני בצד "ימין" שלי.
                // אם אני נוסע דרומה (Z+), הימין שלי הוא X-. 
                // אם אני נוסע צפונה (Z-), הימין שלי הוא X+.
                
                // תיקון לוגיקת נתיבים:
                // מכונית שנוסעת לכיוון Z חיובי -> תהיה ב X שלילי (ביחס לקו האמצע)
                // מכונית שנוסעת לכיוון Z שלילי -> תהיה ב X חיובי
                
                const laneX = roadCenterX + (dir === 1 ? -LANE_OFFSET : LANE_OFFSET);

                t.position.set(laneX, 0, (Math.random()-0.5) * 800);
                if (dir === -1) t.rotation.y = Math.PI; // מסובב את הרכב אם הוא נוסע הפוך
                
                t.userData = { axis: 'z', dir: dir, speed: 0.2 + Math.random()*0.2 };
                scene.add(t);
                traffic.push(t);
            }

            // כבישים אופקיים (ציר X)
            for (let i = 0; i < 20; i++) {
                const t = createCarMesh(trafficColors[Math.floor(Math.random()*trafficColors.length)]);
                const rowIndex = Math.floor((Math.random() - 0.5) * GRID_SIZE);
                const roadCenterZ = rowIndex * TILE_SIZE + TILE_SIZE/2;

                const dir = Math.random() > 0.5 ? 1 : -1;
                // מכונית שנוסעת ימינה (X+) -> תהיה ב Z חיובי (ביחס לקו)
                // מכונית שנוסעת שמאלה (X-) -> תהיה ב Z שלילי
                const laneZ = roadCenterZ + (dir === 1 ? LANE_OFFSET : -LANE_OFFSET);

                t.position.set((Math.random()-0.5) * 800, 0, laneZ);
                t.rotation.y = dir === 1 ? Math.PI/2 : -Math.PI/2;

                t.userData = { axis: 'x', dir: dir, speed: 0.2 + Math.random()*0.2 };
                scene.add(t);
                traffic.push(t);
            }
        }
        spawnTraffic();

        // --- שליטה ---
        const keys = {};
        window.onkeydown = e => keys[e.code] = true;
        window.onkeyup = e => keys[e.code] = false;

        // --- לולאת משחק ---
        let speed = 0, angle = 0;

        function animate() {
            requestAnimationFrame(animate);

            // פיזיקת שחקן
            if (keys['KeyW'] || keys['ArrowUp']) speed += 0.012;
            if (keys['KeyS'] || keys['ArrowDown']) speed -= 0.012;
            speed *= 0.96;
            
            if (Math.abs(speed) > 0.001) {
                const turn = (keys['KeyA'] || keys['ArrowLeft']) ? 0.04 : ((keys['KeyD'] || keys['ArrowRight']) ? -0.04 : 0);
                angle += turn * (speed / 0.6);
            }

            const nextX = player.position.x + Math.sin(angle) * speed;
            const nextZ = player.position.z + Math.cos(angle) * speed;

            // בדיקת התנגשות עם בניינים/מדרכות
            const pBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(nextX, 0.5, nextZ), 
                new THREE.Vector3(2, 1, 4)
            );
            let crash = false;
            for(const box of colliders) {
                if (pBox.intersectsBox(box)) { crash = true; break; }
            }

            if(!crash) {
                player.position.x = nextX;
                player.position.z = nextZ;
            } else {
                speed = -speed * 0.5; // התנגשות
            }
            player.rotation.y = angle;

            // עדכון תנועת AI
            traffic.forEach(t => {
                if (t.userData.axis === 'z') {
                    t.position.z += t.userData.speed * t.userData.dir;
                    // החזרה להתחלה אם יוצאים מהעיר
                    if (Math.abs(t.position.z) > 500) t.position.z = -500 * t.userData.dir;
                } else {
                    t.position.x += t.userData.speed * t.userData.dir;
                    if (Math.abs(t.position.x) > 500) t.position.x = -500 * t.userData.dir;
                }
            });

            // מצלמה עוקבת
            const camDist = 25;
            camera.position.x = player.position.x - Math.sin(angle) * camDist;
            camera.position.z = player.position.z - Math.cos(angle) * camDist;
            camera.position.y = 15;
            camera.lookAt(player.position);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
