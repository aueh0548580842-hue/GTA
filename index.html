<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>עיר עם צמתים ורחובות</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #ui {
            position: absolute; top: 10px; right: 10px;
            color: #ffffff; background: rgba(0,0,0,0.7);
            padding: 10px; border: 1px solid #555; border-radius: 8px;
            pointer-events: none; z-index: 100;
            text-shadow: 1px 1px 2px black;
        }
        #controls {
            position: absolute; bottom: 30px; left: 30px;
            display: grid; grid-template-columns: repeat(3, 70px); grid-gap: 15px;
            z-index: 100;
        }
        .btn {
            width: 70px; height: 70px; background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.6); border-radius: 15px;
            display: flex; align-items: center; justify-content: center;
            color: white; font-size: 30px; user-select: none; backdrop-filter: blur(5px);
        }
        @media (min-width: 1024px) { #controls { display: none; } }
    </style>
</head>
<body>

    <div id="ui">
        <strong>עיר פתוחה - רשת רחובות</strong><br>
        סע בכבישים, פנה בצמתים.<br>
        היזהר לא לעלות על המדרכות!
    </div>

    <div id="controls">
        <div id="up" class="btn">↑</div>
        <div id="left" class="btn">←</div>
        <div id="down" class="btn">↓</div>
        <div id="right" class="btn">→</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- הגדרות העיר ---
        const BLOCK_SIZE = 80; // גודל כל גוש בניינים (מדרכה)
        const ROAD_WIDTH = 30; // רוחב הכביש בין הגושים
        const TILE_SIZE = BLOCK_SIZE + ROAD_WIDTH; // גודל יחידה שלמה (מדרכה + כביש)
        const CITY_SIZE = 6; // גודל העיר (6x6 בלוקים)

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xa0d8ef);
        scene.fog = new THREE.FogExp2(0xa0d8ef, 0.0025); // ערפל

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- טעינת טקסטורות ---
        const textureLoader = new THREE.TextureLoader();
        const asphaltTex = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/terrain/grasslight-big.jpg');
        asphaltTex.wrapS = asphaltTex.wrapT = THREE.RepeatWrapping; asphaltTex.repeat.set(50, 50);

        const concreteTex = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg');
        concreteTex.wrapS = concreteTex.wrapT = THREE.RepeatWrapping; concreteTex.repeat.set(4, 4);

        const buildingTex = textureLoader.load('https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/brick_diffuse.jpg');

        // --- תאורה ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
        dirLight.position.set(100, 200, 50);
        dirLight.castShadow = true;
        dirLight.shadow.camera.top = 200;
        dirLight.shadow.camera.bottom = -200;
        dirLight.shadow.camera.left = -200;
        dirLight.shadow.camera.right = 200;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- בניית הקרקע (הכביש הגדול מתחת להכל) ---
        const groundGeo = new THREE.PlaneGeometry(2000, 2000);
        const groundMat = new THREE.MeshStandardMaterial({ map: asphaltTex, color: 0x444444, roughness: 0.9 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.1; // טיפה למטה כדי למנוע ריצוד
        ground.receiveShadow = true;
        scene.add(ground);

        // --- רשימת המדרכות (לצורך התנגשות) ---
        const colliders = [];

        // --- פונקציה ליצירת "בלוק" עירוני (מדרכה + בניינים) ---
        function createCityBlock(x, z) {
            const blockGroup = new THREE.Group();
            blockGroup.position.set(x, 0, z);

            // 1. המדרכה (הבסיס)
            const sidewalkGeo = new THREE.BoxGeometry(BLOCK_SIZE, 0.8, BLOCK_SIZE);
            const sidewalkMat = new THREE.MeshStandardMaterial({ map: concreteTex, color: 0xcccccc });
            const sidewalk = new THREE.Mesh(sidewalkGeo, sidewalkMat);
            sidewalk.position.y = 0.4;
            sidewalk.receiveShadow = true;
            sidewalk.castShadow = true;
            blockGroup.add(sidewalk);

            // שמירת המיקום הגלובלי של המדרכה לבדיקת התנגשות
            // אנחנו יוצרים תיבה דמיונית סביב המדרכה
            const boundingBox = new THREE.Box3().setFromObject(sidewalk);
            // צריך לעדכן את המיקום האמיתי כי הקבוצה עדיין לא זזה בסצנה כשאנחנו יוצרים אותה
            boundingBox.translate(new THREE.Vector3(x, 0, z)); 
            colliders.push(boundingBox);

            // 2. בניינים על המדרכה
            const buildingMat = new THREE.MeshStandardMaterial({ map: buildingTex, color: 0xaaaaaa });
            
            // בונה 4-9 בניינים בתוך הבלוק הזה
            const numBuildings = 4 + Math.floor(Math.random() * 5);
            for(let i=0; i<numBuildings; i++) {
                const w = 10 + Math.random() * 15;
                const d = 10 + Math.random() * 15;
                const h = 20 + Math.random() * 50;
                
                const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), buildingMat);
                
                // מיקום רנדומלי בתוך גבולות המדרכה
                const range = BLOCK_SIZE / 2 - 10;
                b.position.set(
                    (Math.random() - 0.5) * 2 * range,
                    h / 2 + 0.8, // מעל המדרכה
                    (Math.random() - 0.5) * 2 * range
                );
                b.castShadow = true;
                b.receiveShadow = true;
                blockGroup.add(b);
            }

            // 3. אנשים על המדרכה
            const personGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.8, 8);
            const personMat = new THREE.MeshStandardMaterial({ color: 0x2244aa });
            for(let i=0; i<5; i++) {
                const p = new THREE.Mesh(personGeo, personMat);
                const range = BLOCK_SIZE / 2 - 2;
                p.position.set(
                    (Math.random() - 0.5) * 2 * range,
                    1.7, // גובה אדם + גובה מדרכה
                    (Math.random() - 0.5) * 2 * range
                );
                p.castShadow = true;
                blockGroup.add(p);
            }

            scene.add(blockGroup);
        }

        // --- יצירת הגריד ---
        // לולאה כפולה ליצירת בלוקים
        for (let x = -CITY_SIZE/2; x < CITY_SIZE/2; x++) {
            for (let z = -CITY_SIZE/2; z < CITY_SIZE/2; z++) {
                // המיקום הוא האינדקס כפול גודל היחידה
                createCityBlock(x * TILE_SIZE, z * TILE_SIZE);
            }
        }

        // --- רכב שחקן ---
        function createCar(color) {
            const grp = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.8, 4.8), new THREE.MeshStandardMaterial({ color: color }));
            body.position.y = 0.6;
            body.castShadow = true;
            grp.add(body);
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.6, 2.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            cabin.position.set(0, 1.3, -0.5);
            grp.add(cabin);
            return grp;
        }

        const playerCar = createCar(0xff0000); // רכב אדום
        // מתחילים באמצע צומת (0,0 ממוקם בין בלוקים)
        playerCar.position.set(BLOCK_SIZE/2 + ROAD_WIDTH/2, 0, BLOCK_SIZE/2 + ROAD_WIDTH/2); 
        scene.add(playerCar);

        // --- מכוניות תנועה (AI) ---
        const traffic = [];
        // ציר Z (צפון דרום)
        for(let i=0; i<15; i++) {
            const t = createCar(Math.random() * 0xffffff);
            // בוחרים כביש אקראי (X קבוע, Z משתנה)
            const laneX = Math.floor((Math.random() - 0.5) * CITY_SIZE) * TILE_SIZE + (BLOCK_SIZE/2 + ROAD_WIDTH/2);
            t.position.set(laneX, 0, (Math.random()-0.5) * 1000);
            t.userData = { axis: 'z', speed: 0.3 + Math.random()*0.3 };
            scene.add(t);
            traffic.push(t);
        }
        // ציר X (מזרח מערב)
        for(let i=0; i<15; i++) {
            const t = createCar(Math.random() * 0xffffff);
            // בוחרים כביש אקראי (Z קבוע, X משתנה)
            const laneZ = Math.floor((Math.random() - 0.5) * CITY_SIZE) * TILE_SIZE + (BLOCK_SIZE/2 + ROAD_WIDTH/2);
            t.position.set((Math.random()-0.5) * 1000, 0, laneZ);
            t.rotation.y = Math.PI / 2; // מסובבים את הרכב
            t.userData = { axis: 'x', speed: 0.3 + Math.random()*0.3 };
            scene.add(t);
            traffic.push(t);
        }

        // --- שליטה ---
        const keys = {};
        window.onkeydown = e => keys[e.code] = true;
        window.onkeyup = e => keys[e.code] = false;

        // --- לולאת משחק ---
        let speed = 0, angle = 0;
        
        function animate() {
            requestAnimationFrame(animate);

            // נהיגה
            if (keys['KeyW'] || keys['ArrowUp']) speed += 0.01;
            if (keys['KeyS'] || keys['ArrowDown']) speed -= 0.01;
            speed *= 0.96; // חיכוך
            
            if (Math.abs(speed) > 0.001) {
                const turn = (keys['KeyA'] || keys['ArrowLeft']) ? 0.04 : ((keys['KeyD'] || keys['ArrowRight']) ? -0.04 : 0);
                angle += turn * (speed / 0.5);
            }

            // חישוב המיקום הבא
            const nextX = playerCar.position.x + Math.sin(angle) * speed;
            const nextZ = playerCar.position.z + Math.cos(angle) * speed;

            // בדיקת התנגשות עם מדרכות (האם אני נכנס לתוך מדרכה?)
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(nextX, 0.5, nextZ), 
                new THREE.Vector3(2, 1, 4)
            );

            let collision = false;
            // בדיקה מול כל המדרכות ברשימה
            for (const box of colliders) {
                if (playerBox.intersectsBox(box)) {
                    collision = true;
                    break;
                }
            }

            if (!collision) {
                playerCar.position.x = nextX;
                playerCar.position.z = nextZ;
            } else {
                speed = -speed * 0.5; // "בום" - עצירה ורתיעה
            }
            
            playerCar.rotation.y = angle;

            // עדכון תנועה (AI)
            traffic.forEach(t => {
                if (t.userData.axis === 'z') {
                    t.position.z += t.userData.speed;
                    if(t.position.z > 600) t.position.z = -600;
                } else {
                    t.position.x += t.userData.speed;
                    if(t.position.x > 600) t.position.x = -600;
                }
            });

            // מצלמה עוקבת
            camera.position.x = playerCar.position.x - Math.sin(angle) * 20;
            camera.position.z = playerCar.position.z - Math.cos(angle) * 20;
            camera.position.y = 12;
            camera.lookAt(playerCar.position);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
